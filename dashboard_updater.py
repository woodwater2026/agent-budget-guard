#!/usr/bin/env python3
"""
dashboard_updater.py â€” Real-time cost dashboard for Agent Budget Guard.
Reads live data from cost_calculator (BudgetGuard) and circuit_breaker,
generates dashboard.md, and logs completion.

Usage: python3 dashboard_updater.py
"""

import os
import sys
import time
import json
from datetime import datetime, timezone

# Ensure we can import siblings
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from cost_calculator import BudgetGuard
from circuit_breaker import CircuitBreaker


# â”€â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def load_config(config_path="config.json"):
    if os.path.exists(config_path):
        with open(config_path) as f:
            return json.load(f)
    return {}


def get_circuit_breaker_summary(breaker: CircuitBreaker) -> dict:
    """Extract key metrics from a CircuitBreaker instance."""
    state = breaker.check_state()

    # Clean old events and compute live window sums
    breaker._clean_old_events(breaker.cost_events, breaker.cost_window_seconds)
    breaker._clean_old_events(breaker.token_events, breaker.token_window_seconds)

    window_cost = breaker._get_current_sum(breaker.cost_events)
    window_tokens = breaker._get_current_sum(breaker.token_events)

    return {
        "state": state,
        "cost_limit": breaker.cost_limit,
        "cost_window_seconds": breaker.cost_window_seconds,
        "window_cost": window_cost,
        "window_tokens": window_tokens,
        "token_velocity_limit": breaker.token_velocity_limit,
        "token_window_seconds": breaker.token_window_seconds,
        "cost_failures": breaker.cost_failures,
        "token_failures": breaker.token_failures,
        "last_failure_time": breaker.last_failure_time,
    }


def state_emoji(state: str) -> str:
    return {"CLOSED": "ğŸŸ¢", "OPEN": "ğŸ”´", "HALF_OPEN": "ğŸŸ¡"}.get(state, "âšª")


def spend_velocity(window_cost: float, window_seconds: float) -> float:
    """Return $/hour spend rate based on current window data."""
    if window_seconds <= 0:
        return 0.0
    return window_cost / window_seconds * 3600


def estimated_daily_cost(velocity_per_hour: float) -> float:
    return velocity_per_hour * 24


# â”€â”€â”€ Dashboard Generation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def generate_dashboard(guard: BudgetGuard) -> str:
    now_utc = datetime.now(timezone.utc)
    now_local_str = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    cb = get_circuit_breaker_summary(guard.breaker)
    state = cb["state"]
    window_cost = cb["window_cost"]
    window_tokens = int(cb["window_tokens"])
    cost_limit = cb["cost_limit"]
    window_secs = cb["cost_window_seconds"]

    velocity = spend_velocity(window_cost, window_secs)
    daily_est = estimated_daily_cost(velocity)

    # Determine current model from config
    config = guard.config
    current_model = config.get("default_model", config.get("model", "anthropic/claude-sonnet-4-6"))

    currency = guard.display_currency
    rate = guard.fx_rates.get(currency, 1.0)

    def fmt(usd: float) -> str:
        return f"{currency} {usd * rate:.4f}" if currency != "USD" else f"${usd:.4f}"

    # Circuit breaker status line
    cb_state_line = f"{state_emoji(state)} **{state}**"
    if state == "OPEN":
        since = int(time.time() - cb["last_failure_time"])
        cb_state_line += f" (tripped {since}s ago â€” recovery in {max(0, guard.breaker.recovery_timeout - since)}s)"
    elif state == "HALF_OPEN":
        cb_state_line += " (testing recoveryâ€¦)"

    # Budget health
    pct = (window_cost / cost_limit * 100) if cost_limit > 0 else 0
    if pct < 50:
        health = "âœ… Healthy"
    elif pct < 80:
        health = "âš ï¸ Elevated"
    else:
        health = "ğŸš¨ Critical"

    md = f"""# ğŸŒŠğŸŒ² Agent Budget Guard â€” Real-time Dashboard

> Auto-generated by `dashboard_updater.py` Â· {now_local_str}

---

## ğŸ“Š Session Overview

| Metric | Value |
|--------|-------|
| **Current Model** | `{current_model}` |
| **Display Currency** | {currency} |
| **Dashboard Updated** | {now_local_str} |

---

## ğŸ’° Cost Tracker

| Metric | Value |
|--------|-------|
| **Window Spend** | {fmt(window_cost)} / {fmt(cost_limit)} ({pct:.1f}%) |
| **Window Duration** | {window_secs}s |
| **Token Usage (window)** | {window_tokens:,} / {cb["token_velocity_limit"]:,} |
| **Budget Health** | {health} |

---

## âš¡ Spend Velocity

| Metric | Value |
|--------|-------|
| **Current Rate** | {fmt(velocity)} / hour |
| **Estimated Daily Cost** | {fmt(daily_est)} |
| **Estimated Monthly Cost** | {fmt(daily_est * 30)} |

---

## ğŸ›¡ Circuit Breaker

| Metric | Value |
|--------|-------|
| **State** | {cb_state_line} |
| **Cost Failures** | {cb["cost_failures"]} / {guard.breaker.cost_failure_threshold} |
| **Token Failures** | {cb["token_failures"]} / {guard.breaker.token_failure_threshold} |
| **Recovery Timeout** | {guard.breaker.recovery_timeout}s |

---

## ğŸ¯ Model Pricing Reference

| Model | Input ($/1M) | Output ($/1M) |
|-------|-------------|--------------|
"""
    for model, pricing in guard.model_pricing.items():
        md += f"| `{model}` | ${pricing['input']:.3f} | ${pricing['output']:.2f} |\n"

    md += f"\n---\n*Generated by Agent Budget Guard Â· {now_local_str}*\n"
    return md


# â”€â”€â”€ Logging â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def write_log(base_dir: str, message: str):
    log_dir = os.path.join(base_dir, "staff_logs")
    os.makedirs(log_dir, exist_ok=True)
    date_str = datetime.now().strftime("%Y%m%d")
    log_path = os.path.join(log_dir, f"dashboard_{date_str}.log")
    ts = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    with open(log_path, "a") as f:
        f.write(f"[{ts}] {message}\n")
    return log_path


# â”€â”€â”€ Main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def main():
    base_dir = os.path.dirname(os.path.abspath(__file__))
    config_path = os.path.join(base_dir, "config.json")
    dashboard_path = os.path.join(base_dir, "dashboard.md")

    print("ğŸŒŠ Agent Budget Guard â€” Dashboard Updater")
    print(f"   Base dir: {base_dir}")

    try:
        guard = BudgetGuard(config_path=config_path)
        content = generate_dashboard(guard)

        with open(dashboard_path, "w") as f:
            f.write(content)

        log_path = write_log(base_dir, f"Dashboard updated successfully â†’ {dashboard_path}")
        print(f"âœ… Dashboard written to: {dashboard_path}")
        print(f"ğŸ“ Log entry appended: {log_path}")

    except Exception as e:
        err_msg = f"ERROR: {type(e).__name__}: {e}"
        print(f"âŒ {err_msg}")
        try:
            write_log(base_dir, err_msg)
        except Exception:
            pass
        sys.exit(1)


if __name__ == "__main__":
    main()
